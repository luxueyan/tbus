// Generated by LiveScript 1.3.1
var debug, concat, config, ef, et, protocols, parsedProxyUrl, resolvingPromises, rp, exports, cache;
debug = require('debug')('cc:os:cache');
concat = require("concat-stream");
var db = require('@cc/redis');
config = require("config");
ef = require('./ef');
et = require('errto');
var log = require('bunyan-hub-logger')({app: 'oauth2', name: 'cache'});
protocols = {
    http: require('http'),
    https: require('https')
};
parsedProxyUrl = require('url').parse(config.proxy.market);
resolvingPromises = {};
function ku(key, method, url) {
    return key + "::" + method + "::" + url;
}

// rewrite config
var _ = require('lodash');
_.assign(config.cache, {
  tender: false,
  loan: false
});

rp = require('request-promise');
function createRequestPromise(configKey, key, method, url) {
    var cacheTtl, ref$, p;
    cacheTtl = (ref$ = config.ttlCache) != null ? ref$[configKey] : void 8;
    p = rp({
        resolveWithFullResponse: true,
        timeout: 10000,
        uri: config.proxy.market.replace(/\/$/, '') + url,
        method: method.toUpperCase(),
        hostname: parsedProxyUrl.hostname,
        port: parsedProxyUrl.port,
        headers: {
            host: parsedProxyUrl.host,
            connection: 'close'
        }
    });
    p['finally'](function () {
        return resolvingPromises[ku(key, method, url)] = null;
    });
    return resolvingPromises[ku(key, method, url)] = p.then(function (r) {
        var objForCache, ref$, logError, ref1$;
        objForCache = (ref$ = {
            statusCode: r.statusCode,
            headers: r.headers
        }, ref$.body = r.body || '{}', ref$);
        if ((ref$ = objForCache.headers) != null && ref$['set-cookie']) {
            delete objForCache.headers['set-cookie'];
        }
        logError = log.error.bind(log);
        if (!(200 <= (ref1$ = objForCache != null ? objForCache.statusCode : void 8) && ref1$ < 300)) {
            return objForCache;
        }
        db.hsetnx(key, url, JSON.stringify(objForCache), et(logError, function () {
            return db.ttl(key, et(logError, function (ttl) {
                if (!(ttl > 0)) {
                    return db.expire(key, cacheTtl
                      ? cacheTtl
                      : config.cacheExpireSeconds);
                }
            }));
        }));
        return objForCache;
    });
}
function promiseTogether(configKey, key, method, url) {
    var p;
    p = resolvingPromises[ku(key, method, url)];
    if (!p) {
        p = createRequestPromise(configKey, key, method, url);
    }
    return p;
}
exports = module.exports = cache = function (configKey, key, method, url, cb) {
    var cacheTtl, ref$;
    cacheTtl = (ref$ = config.ttlCache) != null ? ref$[configKey] : void 8;
    url = url.replace(/(\?|&)access_token=[a-f0-9]{64}(&)?/, function (all, pre, sub) {
        if (sub === '&') {
            return pre;
        } else {
            return '';
        }
    });
    return ef(cb, bind$(db, 'hget'), key, url, function (str) {
        var cachedObj, ref$;
        try {
            cachedObj = JSON.parse(str);
            cachedObj.body = cachedObj.body || '{}';
        } catch (e$) {}
        if (200 <= (ref$ = cachedObj != null ? cachedObj.statusCode : void 8) && ref$ < 300) {
            return cb(null, cachedObj);
        }
        return promiseTogether(configKey, key, method, url).then(function (objForCache) {
            return cb(null, objForCache);
        })['catch'](function (err) {
            return cb(err);
        });
    });
};
exports.middleware = curry$(function (configKey, subfix, getId) {
    return function (req, res, next) {
        if (!(config.cache[configKey] && req.authPass)) {
            return next();
        }
        return ef(next, cache, configKey, getId(req) + subfix, 'GET', req.url, function (cachedObj) {
            res.set('Content-Type', 'application/json; charset=utf-8');
            res.statusCode = cachedObj.statusCode;
            return res.end(cachedObj.body);
        });
    };
});
exports.del = function (key, callback) {
  return db.pipeline().del(key).exec(callback);
};
exports.hdel = function (hash, key, callback) {
  return db.pipeline().hdel(hash, key).exec(callback);
};
function bind$(obj, key, target) {
    return function () { return (target || obj)[key].apply(obj, arguments) };
}
function curry$(f, bound) {
    var context,
  _curry = function (args) {
      return f.length > 1 ? function () {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
      } : f;
  };
    return _curry();
}
